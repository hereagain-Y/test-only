//This file contains median difficulty problems on LeetCode
public: vector<int> result;
    void inorder(TreeNode* root){
        if(root==nullptr)
            return;
        inorder(root->left);
        result.push_back(root->val);
        inorder(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        inorder(root);
        return result;
    }
    
    int lengthOfLastWord(string s) {
        int ans = 0;
        for(int i=s.length()-1;i>=0;--i){
            if(s[i] == ' ' && ans > 0) return ans;
            if(s[i] != ' ') ans++;
        }
        return ans;
    }
    
    int triangleNumber(vector<int>& nums) {
        int count=0;
        if(nums.size()<3)
            return 0;
        sort(nums.begin(),nums.end());
        int n=nums.size();
        for(int i=n-1;i>=1;i--){
            int l = 0, r = i - 1;
            while (l < r) {
                if (nums[l] + nums[r] > nums[i]) {
                    count += r - l;
                    r--;
                }
                else
                    l++;
            }
        }
        return count;
    }
/*
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

Example 1
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
*/
    bool check(vector<vector<int>> result,vector<int> target){
        sort(target.begin(),target.end());
        for(int i=0;i<result.size();i++){
            sort(result[i].begin(),result[i].end());
            if(result[i]==target)
                return true;
        }
        return false;
    }
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        vector<int> number;
        if(nums.size()<4)
            return result;
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                for(int k=j+1;k<nums.size();k++){
                    for(int l=k+1;l<nums.size();l++){
                        if(nums[i]+nums[j]+nums[k]+nums[l]==target){
                            number.push_back(nums[i]);
                            number.push_back(nums[j]);
                            number.push_back(nums[k]);
                            number.push_back(nums[l]);
                            if(!check(result,number)){
                                result.push_back(number);
                            }
                            number.clear();
                        }
                    }
                }
            }
        }
        return result;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        stack<ListNode*> mystack;
        ListNode* current = head;
        ListNode* prev = NULL;
 
        while (current != NULL) {

            // Terminate the loop whichever comes first
            // either current == NULL or count >= k
            int count = 0;
            while (current != NULL && count < k) {
                mystack.push(current);
                current = current->next;
                count++;
            }

            // Now pop the elements of stack one by one
            while (mystack.size() > 0) {

                // If final list has not been started yet.
                if (prev == NULL) {
                    prev = mystack.top();
                    head = prev;
                    mystack.pop();
                } else {
                    prev->next = mystack.top();
                    prev = prev->next;
                    mystack.pop();
                }
            }
        }

        // Next of last element will point to NULL.
        prev->next = NULL;

        return head;
    }
    
    int findPeakElement(vector<int>& num) {
        int low = 0, high = num.size() - 1;
        while (low < high - 1) {
            int mid = (low + high) / 2;
            if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1]) 
                return mid;
            else if (num[mid] > num[mid + 1]) 
                    high = mid - 1;
                 else 
                    low = mid + 1;    
        }
        return num[low] > num[high] ? low : high;
    }
    
    int maxSubArray(vector<int>& nums) {
        int curr = INT_MIN, max = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            max = max + nums[i];
            if (curr < max)
                curr = max;
            if (max < 0)
                max = 0;
        }
        return curr;
    }
    
    int partitionDisjoint(vector<int>& nums) {
        vector<int> mx(nums.size()), mi(nums.size());
        mx[0]=nums[0]; mi[nums.size()-1]=nums.back();
        for(int i=1; i<nums.size(); i++)
            mx[i]=max(nums[i], mx[i-1]);
        for(int i=nums.size()-2; i>=0; i--)
            mi[i]=min(nums[i], mi[i+1]);
        int i;
        for(i=0; i<nums.size()-1; i++)
            if(mx[i]<=mi[i+1])
                break;
        return i+1;
    }
    
    int maxArea(vector<int>& height) {
        int l=0,r=height.size()-1,h=0,area=0;
        while(l<r){
            h=height[l]<height[r]?height[l]:height[r];
            area=(r-l)*h>area?(r-l)*h:area;
            if(height[l]<height[r])
                l++;
            else
                r--;
        }
        return area;
    }
    
    int maxArea(vector<int>& height) {
        int max=0;
        for(int i=0;i<height.size();i++){
            for(int j=i+1;j<height.size();j++){
                int w=j-i,h;
                if(height[i]>height[j])
                    h=height[j];
                else
                    h=height[i];
                if(w*h>max)
                    max=w*h;
            }
        }
        return max;
    }
    
    int findIntegers(int num) {
        int f[32];
        f[0] = 1;
        f[1] = 2;
        for (int i = 2; i < 32; ++i)
            f[i] = f[i-1]+f[i-2];
        int ans = 0, k = 30, pre_bit = 0;
        while (k >= 0) {
            if (num&(1<<k)) {
                ans += f[k];
                if (pre_bit) return ans;
                pre_bit = 1;
            }
            else
                pre_bit = 0;
            --k;
        }
        return ans+1;
    }
    
    TreeNode* sortedArrayToBST(vector<int>& num) {
        if(num.size() == 0) return NULL;
        if(num.size() == 1)
        {
            return new TreeNode(num[0]);
        }
        
        int middle = num.size()/2;
        TreeNode* root = new TreeNode(num[middle]);
        
        vector<int> leftInts(num.begin(), num.begin()+middle);
        vector<int> rightInts(num.begin()+middle+1, num.end());
        
        root->left = sortedArrayToBST(leftInts);
        root->right = sortedArrayToBST(rightInts);
        
        return root;
    }
    #include <cmath>
    //abs() is a funtion to find absolute value
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int temp = 0 ;
        int result = nums[0]+nums[1]+nums[2] ;
        while( temp < nums.size() - 2 ){
            int left = temp + 1;
            int right = nums.size() - 1 ;
            while ( left < right ){
                int sum = nums[temp] + nums[left] + nums[right];
                if ( abs(sum-target) < abs(result-target) ) result = sum;
                if ( sum > target ) right -= 1;
                else if ( sum < target ) left += 1;
                else return target;
            }
            temp += 1;
        }
        return result;
    }
