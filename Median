//This file contains median difficulty problems on LeetCode
public: vector<int> result;
    void inorder(TreeNode* root){
        if(root==nullptr)
            return;
        inorder(root->left);
        result.push_back(root->val);
        inorder(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        inorder(root);
        return result;
    }
    
    int lengthOfLastWord(string s) {
        int ans = 0;
        for(int i=s.length()-1;i>=0;--i){
            if(s[i] == ' ' && ans > 0) return ans;
            if(s[i] != ' ') ans++;
        }
        return ans;
    }
    
    int triangleNumber(vector<int>& nums) {
        int count=0;
        if(nums.size()<3)
            return 0;
        sort(nums.begin(),nums.end());
        int n=nums.size();
        for(int i=n-1;i>=1;i--){
            int l = 0, r = i - 1;
            while (l < r) {
                if (nums[l] + nums[r] > nums[i]) {
                    count += r - l;
                    r--;
                }
                else
                    l++;
            }
        }
        return count;
    }
/*
Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

Example 1
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
*/
    bool check(vector<vector<int>> result,vector<int> target){
        sort(target.begin(),target.end());
        for(int i=0;i<result.size();i++){
            sort(result[i].begin(),result[i].end());
            if(result[i]==target)
                return true;
        }
        return false;
    }
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        vector<int> number;
        if(nums.size()<4)
            return result;
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                for(int k=j+1;k<nums.size();k++){
                    for(int l=k+1;l<nums.size();l++){
                        if(nums[i]+nums[j]+nums[k]+nums[l]==target){
                            number.push_back(nums[i]);
                            number.push_back(nums[j]);
                            number.push_back(nums[k]);
                            number.push_back(nums[l]);
                            if(!check(result,number)){
                                result.push_back(number);
                            }
                            number.clear();
                        }
                    }
                }
            }
        }
        return result;
    }
    ListNode* reverseKGroup(ListNode* head, int k) {
        stack<ListNode*> mystack;
        ListNode* current = head;
        ListNode* prev = NULL;
 
        while (current != NULL) {

            // Terminate the loop whichever comes first
            // either current == NULL or count >= k
            int count = 0;
            while (current != NULL && count < k) {
                mystack.push(current);
                current = current->next;
                count++;
            }

            // Now pop the elements of stack one by one
            while (mystack.size() > 0) {

                // If final list has not been started yet.
                if (prev == NULL) {
                    prev = mystack.top();
                    head = prev;
                    mystack.pop();
                } else {
                    prev->next = mystack.top();
                    prev = prev->next;
                    mystack.pop();
                }
            }
        }

        // Next of last element will point to NULL.
        prev->next = NULL;

        return head;
    }
    
    int findPeakElement(vector<int>& num) {
        int low = 0, high = num.size() - 1;
        while (low < high - 1) {
            int mid = (low + high) / 2;
            if (num[mid] > num[mid - 1] && num[mid] > num[mid + 1]) 
                return mid;
            else if (num[mid] > num[mid + 1]) 
                    high = mid - 1;
                 else 
                    low = mid + 1;    
        }
        return num[low] > num[high] ? low : high;
    }
    
    int maxSubArray(vector<int>& nums) {
        int curr = INT_MIN, max = 0;
        for (int i = 0; i < nums.size(); i++)
        {
            max = max + nums[i];
            if (curr < max)
                curr = max;
            if (max < 0)
                max = 0;
        }
        return curr;
    }
    
    int partitionDisjoint(vector<int>& nums) {
        vector<int> mx(nums.size()), mi(nums.size());
        mx[0]=nums[0]; mi[nums.size()-1]=nums.back();
        for(int i=1; i<nums.size(); i++)
            mx[i]=max(nums[i], mx[i-1]);
        for(int i=nums.size()-2; i>=0; i--)
            mi[i]=min(nums[i], mi[i+1]);
        int i;
        for(i=0; i<nums.size()-1; i++)
            if(mx[i]<=mi[i+1])
                break;
        return i+1;
    }
    
    int maxArea(vector<int>& height) {
        int l=0,r=height.size()-1,h=0,area=0;
        while(l<r){
            h=height[l]<height[r]?height[l]:height[r];
            area=(r-l)*h>area?(r-l)*h:area;
            if(height[l]<height[r])
                l++;
            else
                r--;
        }
        return area;
    }
