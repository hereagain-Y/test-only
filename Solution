class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        vector<int> data;
        for(int i=0;i<matrix.size();i++){
            for(int j=0;j<matrix[i].size();j++){
                data.push_back(matrix[i][j]);
            }
        }
        sort(data.begin(),data.end());
        return data[k-1];
    }
    string longestCommonPrefix(vector<string>& strs) {
        int min=100000;
        for(int i= 0;i<strs.size();i++){
            if(strs[i].length()<min)
                min=strs[i].length();
        }
        string result="";
        for(int i=0;i<min;i++){
            char temp=strs[0][i];
            for(int j=0;j<strs.size();j++){
                if(strs[j][i]!=temp)
                    return result;
            }
            result+=temp;
        }
        return result;
    }
    int lengthOfLIS(vector<int>& nums) {
        int n = (int)nums.size();
        if (n == 0) {
            return 0;
        }
        vector<int> dp(n, 0);
        for (int i = 0; i < n; ++i) {
            dp[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
    //check if the parentheses are valid
    bool isValid(string s) {
        stack<char> st;
        for(int i=0;i<s.length();i++){
            if(s[i]=='{')
                st.push(s[i]);
            else if(s[i]=='[')
                st.push(s[i]);
            else if(s[i]=='(')
                st.push(s[i]);
            else if(st.empty())
                return false;
            else if(st.top()=='{'&&s[i]=='}')
                st.pop();
            else if(st.top()=='['&&s[i]==']')
                st.pop();
            else if(st.top()=='('&&s[i]==')')
                st.pop();
            else
                return false;
        }
        if(st.empty())
            return true;
        else
            return false;
    }
    /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* head,*curr;
        if(l1==nullptr)
            return l2;
        else if(l2==nullptr)
            return l1;
        if(l1->val>l2->val){
            head=l2;
            l2=l2->next;
        }else{
            head=l1;
            l1=l1->next;
        }
        curr=head;
        while(l1&&l2){
            if(l1->val>l2->val){
                curr->next=l2;
                l2=l2->next;
            }else{
                curr->next=l1;
                l1=l1->next;
            }
            curr=curr->next;
        }
        if(l1==nullptr)
            curr->next=l2;
        else
            curr->next=l1;
        return head;
    }
};
